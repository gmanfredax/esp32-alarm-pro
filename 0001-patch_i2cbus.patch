diff --git a/main/i2c_bus.h b/main/i2c_bus.h
new file mode 100644
index 0000000..c0ffee1
--- /dev/null
+++ b/main/i2c_bus.h
@@ -0,0 +1,7 @@
+#pragma once
+#include "esp_err.h"
+#include "driver/i2c_master.h"
+
+// Inizializza (se non gi√† fatto) e restituisce l'handle del bus I2C master condiviso.
+esp_err_t i2c_bus_init(void);
+i2c_master_bus_handle_t i2c_bus_get(void);
diff --git a/main/i2c_bus.c b/main/i2c_bus.c
new file mode 100644
index 0000000..deadbee
--- /dev/null
+++ b/main/i2c_bus.c
@@ -0,0 +1,30 @@
+#include "i2c_bus.h"
+#include "esp_check.h"
+#include "esp_log.h"
+#include "pins.h"  // I2C_SDA_GPIO, I2C_SCL_GPIO, I2C_SPEED_HZ
+
+static const char* TAG = "i2c_bus";
+static i2c_master_bus_handle_t s_bus = NULL;
+
+esp_err_t i2c_bus_init(void)
+{
+    if (s_bus) return ESP_OK;
+    i2c_master_bus_config_t bus_cfg = {
+        .clk_source = I2C_CLK_SRC_DEFAULT,
+        .sda_io_num = I2C_SDA_GPIO,
+        .scl_io_num = I2C_SCL_GPIO,
+        .glitch_ignore_cnt = 7,
+        .flags = { .enable_internal_pullup = true } // solo aiuto in debug; restano valide le 10k esterne
+    };
+    ESP_RETURN_ON_ERROR(i2c_new_master_bus(&bus_cfg, &s_bus), TAG, "i2c_new_master_bus failed");
+    ESP_LOGI(TAG, "I2C bus ready: SDA=%d SCL=%d speed=%u", I2C_SDA_GPIO, I2C_SCL_GPIO, I2C_SPEED_HZ);
+    return ESP_OK;
+}
+
+i2c_master_bus_handle_t i2c_bus_get(void)
+{
+    // Se qualcuno chiama prima di init, proviamo a inizializzare noi.
+    if (!s_bus) {
+        if (i2c_bus_init() != ESP_OK) return NULL;
+    }
+    return s_bus;
+}

